// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_DRAGONBONESTEXTURE_FLATBUFFERS_H_
#define FLATBUFFERS_GENERATED_DRAGONBONESTEXTURE_FLATBUFFERS_H_

#include "flatbuffers/flatbuffers.h"


namespace flatbuffers {

struct TextureAtlas;
struct SubTexture;

struct TextureAtlas FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  const flatbuffers::String *imagePath() const { return GetPointer<const flatbuffers::String *>(6); }
  const flatbuffers::Vector<flatbuffers::Offset<SubTexture>> *subTextures() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SubTexture>> *>(8); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* imagePath */) &&
           verifier.Verify(imagePath()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* subTextures */) &&
           verifier.Verify(subTextures()) &&
           verifier.VerifyVectorOfTables(subTextures()) &&
           verifier.EndTable();
  }
};

struct TextureAtlasBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_imagePath(flatbuffers::Offset<flatbuffers::String> imagePath) { fbb_.AddOffset(6, imagePath); }
  void add_subTextures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SubTexture>>> subTextures) { fbb_.AddOffset(8, subTextures); }
  TextureAtlasBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TextureAtlasBuilder &operator=(const TextureAtlasBuilder &);
  flatbuffers::Offset<TextureAtlas> Finish() {
    auto o = flatbuffers::Offset<TextureAtlas>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<TextureAtlas> CreateTextureAtlas(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   flatbuffers::Offset<flatbuffers::String> imagePath = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SubTexture>>> subTextures = 0) {
  TextureAtlasBuilder builder_(_fbb);
  builder_.add_subTextures(subTextures);
  builder_.add_imagePath(imagePath);
  builder_.add_name(name);
  return builder_.Finish();
}

struct SubTexture FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(4); }
  float x() const { return GetField<float>(6, 0); }
  float y() const { return GetField<float>(8, 0); }
  float width() const { return GetField<float>(10, 0); }
  float height() const { return GetField<float>(12, 0); }
  float frameWidth() const { return GetField<float>(14, 0); }
  float frameHeight() const { return GetField<float>(16, 0); }
  float frameX() const { return GetField<float>(18, 0); }
  float frameY() const { return GetField<float>(20, 0); }
  uint8_t rotated() const { return GetField<uint8_t>(22, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<float>(verifier, 6 /* x */) &&
           VerifyField<float>(verifier, 8 /* y */) &&
           VerifyField<float>(verifier, 10 /* width */) &&
           VerifyField<float>(verifier, 12 /* height */) &&
           VerifyField<float>(verifier, 14 /* frameWidth */) &&
           VerifyField<float>(verifier, 16 /* frameHeight */) &&
           VerifyField<float>(verifier, 18 /* frameX */) &&
           VerifyField<float>(verifier, 20 /* frameY */) &&
           VerifyField<uint8_t>(verifier, 22 /* rotated */) &&
           verifier.EndTable();
  }
};

struct SubTextureBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(4, name); }
  void add_x(float x) { fbb_.AddElement<float>(6, x, 0); }
  void add_y(float y) { fbb_.AddElement<float>(8, y, 0); }
  void add_width(float width) { fbb_.AddElement<float>(10, width, 0); }
  void add_height(float height) { fbb_.AddElement<float>(12, height, 0); }
  void add_frameWidth(float frameWidth) { fbb_.AddElement<float>(14, frameWidth, 0); }
  void add_frameHeight(float frameHeight) { fbb_.AddElement<float>(16, frameHeight, 0); }
  void add_frameX(float frameX) { fbb_.AddElement<float>(18, frameX, 0); }
  void add_frameY(float frameY) { fbb_.AddElement<float>(20, frameY, 0); }
  void add_rotated(uint8_t rotated) { fbb_.AddElement<uint8_t>(22, rotated, 0); }
  SubTextureBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SubTextureBuilder &operator=(const SubTextureBuilder &);
  flatbuffers::Offset<SubTexture> Finish() {
    auto o = flatbuffers::Offset<SubTexture>(fbb_.EndTable(start_, 10));
    return o;
  }
};

inline flatbuffers::Offset<SubTexture> CreateSubTexture(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   float x = 0,
   float y = 0,
   float width = 0,
   float height = 0,
   float frameWidth = 0,
   float frameHeight = 0,
   float frameX = 0,
   float frameY = 0,
   uint8_t rotated = 0) {
  SubTextureBuilder builder_(_fbb);
  builder_.add_frameY(frameY);
  builder_.add_frameX(frameX);
  builder_.add_frameHeight(frameHeight);
  builder_.add_frameWidth(frameWidth);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_name(name);
  builder_.add_rotated(rotated);
  return builder_.Finish();
}

inline const TextureAtlas *GetTextureAtlas(const void *buf) { return flatbuffers::GetRoot<TextureAtlas>(buf); }

inline bool VerifyTextureAtlasBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<TextureAtlas>(); }

inline void FinishTextureAtlasBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<TextureAtlas> root) { fbb.Finish(root); }

}  // namespace flatbuffers

#endif  // FLATBUFFERS_GENERATED_DRAGONBONESTEXTURE_FLATBUFFERS_H_
